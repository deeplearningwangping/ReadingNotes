## Command模式
命令（Command）模式属于对象的行为模式【GOF95】。命令模式又称为行动（Action）模式或事务（Transaction）模式。命令模式把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。

适用性：在软件系统中，行为请求者与行为实现者之间通常呈现一种紧耦合的关系。但在某些场合，比如要对行为进行记录撤销重做事务等处理，这种无法抵御变化的紧耦合是不合适的。这种情况下，使用command模式将行为请求者与行为实现者进行解耦。

## Active Object模式
主动对象设计模式使方法执行与方法调用去耦合，以增强并发、并简化对驻留在它自己的线程控制中的对象的同步访问。

一种异步编程思想，允许任务的提交（相当于对异步方法的调用）和任务的执行（相当于异步方法的真正执行）分离，实现了异步编程。
有利于提高并发性，从而提高系统的吞吐率。

## 模板方法模式（Template Method）
* 提高代码复用性 ，将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中
* 实现了反向控制 ，通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 & 符合“开闭原则”

## 策略模式
在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。

## Facade模式
Facade（外观）模式为子系统中的各类（或结构与方法）提供一个简明一致的界面，隐藏子系统的复杂性，使子系统更加容易使用。它是为子系统中的一组接口所提供的一个一致的界面。

## Mediator模式
用于模块间解耦，通过避免对象互相显式的指向对方从而降低耦合。

## 单例模式
这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

## Mono State模式
Mono State模式是另外一种获取对象单一性的方法。它是红完全不同的工作机制

和单例模式和Mono State模式对比：

* Singleton强制结构上的单一性.
* Mono-State强制行为上的单一性.
* Mono-State的测试case对Singleton是有效的.但是反之不行.
* 如果希望透过派生去约束一个现存类,并且不介意它的所有调用者都必须要调用instance()来获取访问权,使用Singleton.
* 如果希望类的单一性本质对调用者透明,或者使用单一对象的多态派生对象.使用Mono-State.