## 面向对象的一些原则
- 单一职责原则
- 开放-封闭原则
- Liskov替换原则
- 依赖倒置原则
- 接口隔离原则

什么是软件设计？
源代码就是设计

## 设计的臭味
- 僵化性
- 脆弱性
- 牢固性
- 粘滞性
- 不必要的复杂性
- 晦涩性

开发者必须站在代码阅读者的位置，共同努力的对他们的代码进行重构，这样代码的阅读者就可以理解代码，他们的代码也需要被其他人评审。需求是项目中最不稳定的因素，所以应该保持系统设计尽可能的干净、简单，并使用单元测试和验收测试支持，团队利用这种灵活性，持续改进设计，以便于每次迭代结束所生成的系统都具有最适合那种迭代中需求的设计。

## 糟糕的 Copy 程序
编写一个从键盘读入输入字符并输出到打印机的程序，这段代码很简单
```C
void Copy()
{
    int c;
    while((c=RdKbd() != EOF))
        WrtPrt(c);
}
```
第一次需求变更：Copy程序要求能从纸带读入机中读入信息。所以就使用一个全局boolean变量以及三目运算解决
```C
bool ptFlag = false;
// remember to reset this flag
void Copy()
{
    int c;
    while((c=(ptFlag ? Rdpt() : RdKbd()))!= EOF))
        WrtPrt(c);
}
```
第二次需求变更：Copy程序可以输出到纸带穿孔机上。所以就再增加一个全局boolean变量以及三目运算解决
```C
bool ptFlag = false;
bool punchFlag = false;
// remember to reset this flag
void Copy()
{
    int c;
    while((c=(ptFlag ? Rdpt() : RdKbd()))!= EOF))
        punchFlag() ? WrtPunch(c) : WrtPrt(c);
}
```
 可以发现，两次需求变更后，程序的设计已经变得很糟糕，后面的维护会很困难。所以我们的工作就是要保证我们的软件能够经受住那些变化。如果我们软件的设计由于需求变化了而退化，那么我们就不是敏捷的！！

## Copy 程序的敏捷设计
```Java
class Reader
{
    public:
        virtual int read() = 0;      
};
class keyboardReader :  public Reader
{
    public:
        virtual int read() { return RdKbd(); }
}
KeyboardReader GdefaultReader;
void Copy(reader& reader = GdefaultReader)
{
      int c;
      while((c=RdKbd() != EOF))
        WrtPrt(c);
}
```
所以说当有需求来时，要考虑一个最符合当下的设计，并且最好能应付未来的变化！

**有新需求时，应该抓住这次机会去改进设计，以便设计对于将来的同类变化具有弹性，而不是设法去给设计打补丁！！**

**什么是敏捷设计？**

敏捷设计是一个过程，不是一个事件。它是一个持续的应用原则、模式以及实践来改进软件的结构和可读性的过程。它致力于保持系统设计在任何时间都尽可能的简单、干净以及富有表现力


## 单一职责原则（SRP）
在 SRP 中，变化的原因就是职责。如果能想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。

遵守单一职责原则，将不同的职责封装到不同的类或模块中

看完这一章的感觉就是看似懂了，又貌似没懂！所以找了一个 [例子](http://www.cnblogs.com/TomXu/archive/2012/01/06/2305513.html) 参考一下

## 开放-封闭原则
两个主要特征：
- 对于扩展是开放的
- 对于更改是封闭的
这一章感觉讲的就是如何更合理的设计类和方法，如何设计出耦合度低的代码