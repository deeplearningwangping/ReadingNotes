## 面向对象的一些原则
- 单一职责原则
- 开放-封闭原则
- Liskov替换原则
- 依赖倒置原则
- 接口隔离原则

什么是软件设计？
源代码就是设计

## 设计的臭味
- 僵化性
- 脆弱性
- 牢固性
- 粘滞性
- 不必要的复杂性
- 晦涩性

开发者必须站在代码阅读者的位置，共同努力的对他们的代码进行重构，这样代码的阅读者就可以理解代码，他们的代码也需要被其他人评审。需求是项目中最不稳定的因素，所以应该保持系统设计尽可能的干净、简单，并使用单元测试和验收测试支持，团队利用这种灵活性，持续改进设计，以便于每次迭代结束所生成的系统都具有最适合那种迭代中需求的设计。

## 糟糕的 Copy 程序
编写一个从键盘读入输入字符并输出到打印机的程序，这段代码很简单
```C
void Copy()
{
    int c;
    while((c=RdKbd() != EOF))
        WrtPrt(c);
}
```
第一次需求变更：Copy程序要求能从纸带读入机中读入信息。所以就使用一个全局boolean变量以及三目运算解决
```C
bool ptFlag = false;
// remember to reset this flag
void Copy()
{
    int c;
    while((c=(ptFlag ? Rdpt() : RdKbd()))!= EOF))
        WrtPrt(c);
}
```
第二次需求变更：Copy程序可以输出到纸带穿孔机上。所以就再增加一个全局boolean变量以及三目运算解决
```C
bool ptFlag = false;
bool punchFlag = false;
// remember to reset this flag
void Copy()
{
    int c;
    while((c=(ptFlag ? Rdpt() : RdKbd()))!= EOF))
        punchFlag() ? WrtPunch(c) : WrtPrt(c);
}
```
 可以发现，两次需求变更后，程序的设计已经变得很糟糕，后面的维护会很困难。所以我们的工作就是要保证我们的软件能够经受住那些变化。如果我们软件的设计由于需求变化了而退化，那么我们就不是敏捷的！！

## Copy 程序的敏捷设计
```Java
class Reader
{
    public:
        virtual int read() = 0;      
};
class keyboardReader :  public Reader
{
    public:
        virtual int read() { return RdKbd(); }
}
KeyboardReader GdefaultReader;
void Copy(reader& reader = GdefaultReader)
{
      int c;
      while((c=RdKbd() != EOF))
        WrtPrt(c);
}
```
所以说当有需求来时，要考虑一个最符合当下的设计，并且最好能应付未来的变化！

**有新需求时，应该抓住这次机会去改进设计，以便设计对于将来的同类变化具有弹性，而不是设法去给设计打补丁！！**

**什么是敏捷设计？**

敏捷设计是一个过程，不是一个事件。它是一个持续的应用原则、模式以及实践来改进软件的结构和可读性的过程。它致力于保持系统设计在任何时间都尽可能的简单、干净以及富有表现力


## 单一职责原则（SRP）
在 SRP 中，变化的原因就是职责。如果能想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。

遵守单一职责原则，将不同的职责封装到不同的类或模块中

看完这一章的感觉就是看似懂了，又貌似没懂！所以找了一个 [例子](http://www.cnblogs.com/TomXu/archive/2012/01/06/2305513.html) 参考一下

## 开放-封闭原则
两个主要特征：
- 对于扩展是开放的
- 对于更改是封闭的

这一章感觉讲的就是如何更合理的设计类和方法，如何设计出耦合度低的代码

## Liskov替换原则
子类型必须能够替换掉他们的基类型

正方形和矩形的例子有点难理解！

从网上找了一个不错的答案：
> 里氏替换原则有至少以下两种含义：1. 里氏替换原则是针对继承而言的，如果继承是为了实现代码重用，也就是为了共享方法，那么共享的父类方法就应该保持不变，不能被子类重新定义。子类只能通过新添加方法来扩展功能，父类和子类都可以实例化，而子类继承的方法和父类是一样的，父类调用方法的地方，子类也可以调用同一个继承得来的，逻辑和父类一致的方法，这时用子类对象将父类对象替换掉时，当然逻辑一致，相安无事。2. 如果继承的目的是为了多态，而多态的前提就是子类覆盖并重新定义父类的方法，为了符合LSP，我们应该将父类定义为抽象类，并定义抽象方法，让子类重新定义这些方法，当父类是抽象类时，父类就是不能实例化，所以也不存在可实例化的父类对象在程序里。也就不存在子类替换父类实例（根本不存在父类实例了）时逻辑不一致的可能。不符合LSP的最常见的情况是，父类和子类都是可实例化的非抽象类，且父类的方法被子类重新定义，这一类的实现继承会造成父类和子类间的强耦合，也就是实际上并不相关的属性和方法牵强附会在一起，不利于程序扩展和维护。 如何符合LSP？总结一句话 —— 就是尽量不要从可实例化的父类中继承，而是要使用基于抽象类和接口的继承。

## 依赖倒置原则
1. 高层模块不应该依赖于底层模块。二者都应该依赖于对象
2. 抽象不应该依赖于细节。细节应该依赖于抽象

[https://blog.csdn.net/zhengzhb/article/details/7289269](https://blog.csdn.net/zhengzhb/article/details/7289269)

## 接口隔离原则

与单一职责原则的区别:

1. 单一职责原则注重的是职责；而接口隔离原则注重对接口依赖的隔离。
2. 单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口，主要针对抽象，针对程序整体框架的构建。
[https://blog.csdn.net/zhengzhb/article/details/7296921](https://blog.csdn.net/zhengzhb/article/details/7296921)
