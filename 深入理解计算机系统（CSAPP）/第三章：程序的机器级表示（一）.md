当我们用高级语言编程的时候，机器屏蔽了程序的细节，即机器级的实现。高级语言提供的抽象级别比较高，大多数时候，在这种抽象级别上工作效率会更高，也更可靠。编译器提供的类型检查能帮助我们发现许多程序错误，并能够保证按照一致的方式来引用和处理数据。

## 机器级编程的两种抽象
1. 由`指令集体系结构或指令集架构`来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响
2. 机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组
## 数据格式
大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如，数据传送指令有四个变种
- movb(传送字节)
- movw(传送字)
- mov1(传送双字)
- movq(传送四字)
## 访问信息
一个`x86-64`的中央处理单元包含一组16个存储64位值的`通用目的寄存器`。这些寄存器用来存储整型数据和指针。16个寄存器，他们的名字都是%r开头。

大多数指令有一个或多个操作数，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。
各种不同的操作数的可能性被分为三种类型。
1. 立即数，用来表示常数
2. 寄存器，表示某个寄存器的内容
3. 内存引用，它会根据计算出来的地址访问某个内存位置

数据传送指令示例
```c
long exchange(long *xp, long y)
{
    long x = *xp;
    *xp = y;
    return x;
}
```
C代码转成汇编后，变成：
```
long exchange(long *xp, long y)
xp in %rdi, y in %rsi
exchange:
    movq      (%rdi), %rax
    movq      %rsi, (%rdi)
    ret
```

**C语言中所谓的指针，其实就是地址。间接引用指针就是就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器。像X这样的局部变量通常是保存在寄存器中，而不是在内存中。访问寄存器比访问内存要快得多**
## 算术和逻辑运算
事实上，给出的每个指令类都有四种不同大小数据的指令。这次操作被分为四组
- 加载有效地址
- 一元操作
- 二元操作
- 移位