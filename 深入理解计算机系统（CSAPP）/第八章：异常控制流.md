## 异常

#### 异常表
系统对每种可能出现的异常都分配了一个唯一的非负整数异常号，前一部分由处理器设计师分配，如零除，缺页，内存访问违例，其他号码由操作系统内核设计师分配，如系统调用和外部I/O信号
异常表中的表目k就对应着异常k的处理程序代码的地址，异常表的起始地址放在一个叫做异常表基址寄存器的特殊寄存器中
当处理器检测到事件的发生，并确定事件发生对应的异常号后，处理器通过执行间接过程调用，触发异常，并通过异常表上的对应程序进行处理

#### 异常和过程调用的区别
异常处理程序运行在内核模式下，因此对系统资源有完全的访问权限
处理程序如果从用户程序转移到内核，则处理程序将被压入内核栈中，而不是用户栈中
处理器会把一些额外的处理器状态压入栈中，当重新执行程序时需要这些状态
过程调用在跳转到处理程序之前，将返回地址压入栈中，异常处理则根据类型，返回地址要么是当前指令，要么是下一条指令

#### 分类
   1. 中断：一般是由硬件引起的中断，为异步发生。当产生中断后，标记中断位，然后cpu响应中断，然后根据中断向量表，调用响应的中断处理程序处理中断。
   2. 陷阱：为同步异常，当应用程序需要调用系统级函数的时候，就产生自陷异常。从用户层调入系统层，从而执行系统函数。陷阱的作用是在用户程序和内核之间提供一个象过程一样的接口。陷阱返回到下一条指令。
   3. 故障：为同步异常。其是由错误引起的异常，不过其错误是可以被修复的。如缺页。
   4. 终止：为同步异常。其是由不可恢复的致命错误造成的。典型的为一些硬件错误，

## 进程
进程的定义就是一个执行中的程序实例，通过进程能给我们提供一个假象，好像当前程序是系统中唯一运行的程序一样，好像该程序能独占处理器和内存。但其实每个程序都运行在某个进程的上下文中（上下文包括程序代码和数据，栈、通用目的寄存器的内容，程序计数器，环境变量等）

例如当在shell中输入./hello时，shell就会创建一个新的进程，并在该进程的上下文中执行它

进程为应用程序提供了关键两点抽象

独立的逻辑控制流：程序独占处理器的假象
私有的地址空间：程序独占内存系统的假象
