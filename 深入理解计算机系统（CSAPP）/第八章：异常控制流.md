## 异常

#### 异常表
系统对每种可能出现的异常都分配了一个唯一的非负整数异常号，前一部分由处理器设计师分配，如零除，缺页，内存访问违例，其他号码由操作系统内核设计师分配，如系统调用和外部I/O信号
异常表中的表目k就对应着异常k的处理程序代码的地址，异常表的起始地址放在一个叫做异常表基址寄存器的特殊寄存器中
当处理器检测到事件的发生，并确定事件发生对应的异常号后，处理器通过执行间接过程调用，触发异常，并通过异常表上的对应程序进行处理

#### 异常和过程调用的区别
异常处理程序运行在内核模式下，因此对系统资源有完全的访问权限
处理程序如果从用户程序转移到内核，则处理程序将被压入内核栈中，而不是用户栈中
处理器会把一些额外的处理器状态压入栈中，当重新执行程序时需要这些状态
过程调用在跳转到处理程序之前，将返回地址压入栈中，异常处理则根据类型，返回地址要么是当前指令，要么是下一条指令

#### 分类
   1. 中断：一般是由硬件引起的中断，为异步发生。当产生中断后，标记中断位，然后cpu响应中断，然后根据中断向量表，调用响应的中断处理程序处理中断。
   2. 陷阱：为同步异常，当应用程序需要调用系统级函数的时候，就产生自陷异常。从用户层调入系统层，从而执行系统函数。陷阱的作用是在用户程序和内核之间提供一个象过程一样的接口。陷阱返回到下一条指令。
   3. 故障：为同步异常。其是由错误引起的异常，不过其错误是可以被修复的。如缺页。
   4. 终止：为同步异常。其是由不可恢复的致命错误造成的。典型的为一些硬件错误，

## 进程
进程的定义就是一个执行中的程序实例，通过进程能给我们提供一个假象，好像当前程序是系统中唯一运行的程序一样，好像该程序能独占处理器和内存。但其实每个程序都运行在某个进程的上下文中（上下文包括程序代码和数据，栈、通用目的寄存器的内容，程序计数器，环境变量等）

例如当在shell中输入./hello时，shell就会创建一个新的进程，并在该进程的上下文中执行它

进程为应用程序提供了关键两点抽象

独立的逻辑控制流：程序独占处理器的假象

私有的地址空间：程序独占内存系统的假象

## 进程控制

Unix提供了很多从C程序中操作进程的系统调用，比如比较简单的 pid_t getpid(void) 和 pid_t getppid(void)获取当前执行进程的pid和其父进程的pid。pid_t是pid的类型，在Linux系统中在 sys/types.h 定义为int。这两个函数包含在 unistd.h 中。

创建和终止进程
首先要了解进程的状态，从程序员的角度看，我们可以认为进程总是处于下面三种状态之一：

运行。进程要么在CPU上执行，要么在等待执行且最终会被内核调度
停止。进程的执行被挂起（suspend），且不会被调度。直到它收到一个 SIGCONT 信号会再次开始执行
终止。进程永远地停止了。进程终止有三种原因：收到终止进程的信号；从主程序返沪；调用了exit函数
从操作系统的角度看会有更多的状态，但是在程序员的角度看，只需要了解这三个状态就可以了。

创建一个进程和终止一个进程都是用系统调用函数，即fork和exit，其函数声明如下：
```
void exit(int status);
pid_t fork(void);
```
其中exit声明在 stdlib.h， 而fork声明在 unistd.h 中。
新创建的进程几乎（但是不完全）和父进程相同。子进程得到父进程虚拟地址空间相同的一份拷贝，包括文本，数据和bss段、堆以及用户栈；子进程还会获得与父进程打开的文件描述符相同的拷贝，也就是说子进程可以读写父进程打开的任何文件。理解这部分是很重要的，否则对于多进程的执行会难以理解。由于子进程几乎就是对父进程的一个复制，所以他们的PC（程序计数器）都是指向同样的虚拟地址，这在后面的示例程序中很重要。父子进程之间最大的区别只是它们的PID不同。

fork 函数非常不同的一点是它只被调用一次，却会返回两次，一次是返回子进程的PID给父进程，一次是在新创建的子进程中返回0。在我们的程序中使用这个不同的PID（肯定是一个0一个非0）判断当前是父进程还是子进程。这和其他高级语言的并行程序设计很不一样（不过像Java等一般是多线程，很少用多进程）。看下面一个我修改过的经典示例：
```
#include <stdio.h>
#include <unistd.h>

void exit(int);    // 函数声明，防止vim保存时报错

int main(void) {
    int a[] = {1,2,3,4};
    pid_t pid = fork();
    // 子进程和父进程都会执行之后的代码
    if (pid == 0) {
        a[0] = 11;
        a[1] = 22;
        printf("fork pid is %5d, a is %d, %d, %d, %d\n", pid, a[0], a[1], a[2], a[3]);
        //exit(0); // if no exit here, it will go-on to the rest lines of(15+) of main
        return 0;
    }
    a[0] = 111;
    a[1] = 222;
    a[3] = 444;
    printf("main pid is %5d, a is %d, %d, %d, %d\n", pid,  a[0], a[1], a[2], a[3]);
    exit(0);
}
```
可以在一个Linux系统编译运行这段代码，尝试取消注释和注释子进程中的 exit(0) 调用看看前后的区别。

通过上面的示例，我们知道子进程是由一份独立的拷贝，实际上操作系统课程也讲到过，进程之间使用的是独立的地址空间，相互不会影响，所以也不难理解了。不过虽然数据是独立的，但是父子进程共享打开的文件，对同一个文件资源的操作还是反映在同一个文件上的。

#### 回收子进程
进程终止时，不会立即被内核从系统中清除，将保持在一种已经终止的状态，这种终止但是没有被回收的进程称为僵死进程，这种进程虽然终止，但是依旧会消耗内存资源

当父进程回收僵死进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程

系统驱动时就会启动一个由内核创建的init进程，它是无敌进程，不会终止，而且是所有进程的祖先，其PID为1

如果父进程终止，内核将安排init进程成为被父进程抛弃的孤儿进程的养父，如果父进程的底下存在僵死的子进程没有被回收，内核就安排init进程去回收他们## 信号
