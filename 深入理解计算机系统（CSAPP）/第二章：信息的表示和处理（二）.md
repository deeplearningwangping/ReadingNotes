## 有符号数和无符号数
有符号数，顾名思义就是有正负，可以表示特定类型规定范围内的整数（包括负数），而无符号数只能表示非负数（0和正数）

若将有符号数转换为二进制，则其数值类型允许的最左一位用于表示符号（1为负数，0为正数和0），但在无符号数中，最左一位与其右各位一样用于表示数值。所以有符号数二进制是不对称的

## 原码、反码、补码
原码是指将最高位作为符号位（0表示正，1表示负），其他数字位代表数值本身的绝对值的数字表示方式。
例如在8位机器上，数字6的原码为0 000 0110，而-6的原码为1 000 0110

反码：如果是正数，则表示方法和原码一样，如果是负数，符号位不变，其余各位取反。
例如在8位机器上，数字6的反码为0 000 0110，而-6的f反码为1 111 1001

补码：如果是正数，则表示方法和原码一样，如果是负数，则将数字的反码加上1（相当于将原码数值位取反然后在最低位加1）
例如在8位机器上，数字6的补码为0 000 0110，而-6的补码为1 111 1010

0的反码、补码都是0

根据补码求原码，把补码当成原码，再求一次补码即可。

## 有符号数和无符号数的转换
对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：**数值可能会改变，但是位模式不变**。

当数据类型转换时，同时需要在不同数据大小以及无符号数和有符号数之间转换。C语言标准要求先进行数据大小的转换，之后再进行无符号和有符号之间的转换。

比如：
```
short int v = -12345;
unsigned short uv = (unsigned short)v;
printf("v = %d, uv = %u\n”, u, uv);
```
输出
```
v = -12345, uv = 53191
```
由于-12345的16位补码表示与53191的16位无符号表示是完全一样的，所以会得到以上输出。
无符号数和有符号数之间的转换是一一对应的关系，w位的有符号数s转换无符号数u的对应关系为：
如4位有符号数7（0111）转换为无符号数也是7，而4位有符号数-1（1111）转换为无符号数是15。
类似地，w位的无符号数u转换为有符号数s的对应关系为：
如4位无符号数5（0101）转换为无符号数也是5，而4位无符号数13（1101）转换为无符号数为-3。
其实只要知道无符号数和有符号数对二进制位的解释方式，无需记住上述的对应关系，也能算出转换后的值。

## 浮点数
[看完这篇文章，你肯定理解什么是浮点数了！](https://mp.weixin.qq.com/s/34Fg9GSqRDoBbGFPzOt_ow)



