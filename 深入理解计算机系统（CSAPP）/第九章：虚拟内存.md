虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。

## 虚拟内存提供了三个重要的能力
1. 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存
2. 它为每个进程提供了一致的地址空间，从而简化了内存管理
3. 它保护了每个进程的地址空间不被其他进程破坏
## 物理和虚拟地址
计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组。每字节都有一个唯一地物理地址(Physical Address, PA)。第一个字节的地址为0，接下来的字节地址为1，再下一个为2，以此类推。给这种简单的结构，CPU访问内存的最自然的方式就是使用物理地址。这种方式称为物理寻址。
早期的PC使用物理地址，而且诸如数字信号处理器、嵌入式微控制器以及Cray超级计算机这样的系统仍然继续使用这种寻址方式。
 使用虚拟寻址，CPU通过生成一个虚拟地址(Virtual Address, VA)来访问主存，这个虚拟地址在被送到内存之前先转换成适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做 地址翻译。就像异常处理一样，地址翻译需要CPU硬件和操作系统之间的紧密合作。CPU芯片上叫做内存管理单元(Memory Management Unit， MMU)的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理。

## 虚拟内存作为缓存的工具
概念上而言，虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一地虚拟地址，作为到数组的索引。磁盘上数组的内容被缓存在主存中。和存储器层次结构中其它缓存一样，磁盘(较低层)上的数据被分割成块，这些块作为磁盘和主存(较高层)之间的传输单元。VM系统通过将虚拟内存分割为称为虚拟页(Virtual Page， VP)的大小固定的块来处理这个问题。每个虚拟页的大小为  字节。类似地，物理内存被分割为物理页(Physical Page，PP)，大小也为P字节(物理页也被称为页帧)。
 一个地址空间的大小由表示最大地址所需要的位数来描述的。例如，一个包含N =  个地址虚拟地址空间就叫做一个n位地址空间。现代系统通常支持32位或者64位虚拟地址空间。
       在任意时刻，虚拟页面的集合都分为三个不想交的子集:
       ● 未分配的：VM系统还未分配(或者创建)的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。
      ● 缓存的：当前已缓存在物理内存中的已分配页。
      ● 未缓存的： 未缓存在物理内存中的已分配页。

## DRAM缓存的组织结构
在存储层次结构中，DRAM缓存的位置对它的组织结构有很大的影响。回想一下，DRAM比SRAM要慢大约10倍，而磁盘要比DRAM慢大约100 000多倍。一次DRAM缓存中的不命中比起SRAM缓存中的不命中要昂贵的多，这是因为DRAM缓存不命中要由磁盘来服务，而SRAM缓存不命中通常是由基于DRAM的主存来服务的。而且，从磁盘的第一个扇区读取第一个字节的时间开销比起读这个扇区中连续的字节慢大约100 000倍。
      因为大的不命中处罚和访问第一个字节的开销，虚拟页往往很大，通常是4KB~2MB。

## Linux虚拟内存区域
任务结构中的元素包含或者指向内核运行该进程所需要的所有信息(例如，PID、指向用户栈的指针、可执行目标文件的名字，以及程序计数器)。
        任务结构中的一个条目指向mm_struct，它描述了虚拟内存的当前状态。我们感兴趣的两个字段是pgd和mmap，其中pgd指向第一级页表(页全局目录)的基址，而mmap指向一个vm_area_structs(区域结构)的链表，其中每个vm_area_structs都描述了当前虚拟地址空间的区域。当内核运行这个进程时，就将pgd存放在CR3控制寄存器中。
 一个具体区域结构包含下面的字段:
*  vm_start： 指向这个区域的起始处。
* vm_end： 指向这个区域的结束处。
* vm_prot： 描述这个区域内包含的所有页的读写许可权限。
* vm_flags：描述这个区域内的页面是与其他进程共享的，还是这个进程私有的(还描述了其他一些信息)。
*  vm_next： 指向链表中的下一个区域结构。

## 内存映射
Linux通过将虚拟内存区域与磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射。

