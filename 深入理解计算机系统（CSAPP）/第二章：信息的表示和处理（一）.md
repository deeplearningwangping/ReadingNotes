
## 知识点
- 1.字节顺序：大端和小端
- 2.运行 图2-24，图2-25程序show-bytes.c观察结果，看看有什么问题
- 3.理解布尔运算、位运算
- 4.理解无符号数和有符号数，给一个数，能计算出补码
- 5.理解浮点数的表示法，给一个十进制小数，能转换成二进制浮点数表示


## has表为什么速度快？
hash表比红黑树之类的都要快。因为hash表内部本质上是使用了数组。数组为什么最快？因为我们知道数组的起始地址以及某个元素的序号，就可以得到该元素在内存中的地址，而对于内存，访问任意一个地址，访问时间是相同的。而类似链表、树等机构，只能遍历。
## [虚拟内存](https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98)
虚拟内存使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分割成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。
虚拟内存将主存看成一个磁盘的高速缓存，主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据。从概念上来说，虚拟内存被组织成为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组，也就是字节数组。每个字节都有一个唯一的虚拟地址作为数组的索引。虚拟内存的地址和磁盘的地址之间建立映射关系。磁盘上活动的数组内容被缓存在主存中。在存储器层次结构中，磁盘的数据被分割成块，这些块作为和主存之间的存储单元。主存作为虚拟内存的缓存。

## 寻址空间和寻址能力
寻址空间一般指CPU对于内存寻址的能力，就是能最多用到多少内存。CPU最大能查找多大范围的地址叫寻址能力，CPU的寻址能力以字节为单位。通常，内存容量越大，处理数据的能力就越强，但内存容量不能无限大，要受到系统结构、硬件设计、制造成本等多方面因素的制约，一个最直接的因素取决于系统地址总线和地址寄存器的宽度（位数），这个地址总线宽度和寄存器位数一般是相同的，这个宽度（位数）就是我们所说的32位、64位。32位CPU寻址能力为2的32次方，64位同理。由此可以推出：地址总线为N位的CPU寻址范围是2的N次方字节。
## 为什么是2的N次方，而不是其他数的N次方？
因为计算机采用二进制计算，所有物理元件只有0，1两种状态。假设1根地址总线连接了a、b，那么当地址线上的电压是高电压时读a,低电压读b。那么2根地址线就可以对4个存储单元寻址，对应的电压可以是：低低，低高，高低，高高，而3根地址线就可以对8个存储单元进行寻址，对应的组合为:111,110,100,000,101,100,001,011。以此类推。

## 32位和64位
首先要明确：**既有32位和64位的CPU，又有32位和64位的操作系统，又有32位和64位的软件！**
- 设计初衷不同。64位操作系统的设计初衷是满足机械设计和分析、三维动画、视频编辑和创作，以及科学计算和高性能计算应用程序等领域中需要大量内存和浮点性能的客户需求。也就是说是给专业人员使用的。而32位操作系统是为普通用户设计的。
- 要求配置不同。64位操作系统只能安装在64位电脑上（64位CPU），同时要安装64位软件才能发挥64位的最佳性能。这三者缺一不可。而32位操作系统可以安装在32位电脑（32位CPU）或64位电脑（64位CPU）。但是32位操作系统安装在64位电脑上并不能发挥64位的优势，浪费了64位CPU这个硬件优势。
- 寻址能力不同。32位最大支持4G，64位最大支持大约16E。
- 软件支持不同。64位系统可以运行32位软件和64位软件。32位系统只能运行32位软件，并且只能安装在32位CPU上。目前64位软件比32位少的多。

## x86
x86指的是一种cpu架构，因为intel的8086，286，386-586而得名，amd开发的大部分cpu也是基于x86架构。x86架构的特点是cpu的寄存器是32位的，基于32位cpu开发的操作系统就叫32位操作系统，32位操作系统也通常被成为x86系统。 X86架构采用CISC（复杂指令集），而ARM采用RISC（精简指令集）。ARM处理器非常适用于移动通信领域，具有低成本、高性能和地电耗的特性。

## 为什么没有128位甚至更多位的处理器呢？
处理器的位数是用通用寄存器的宽度来定义的。常规的整数运算是用不到这么大的寄存器的，真正的大数运算也不会用这种方式实现，而现代的32位、64位处理器中，更重要的浮点运算所使用的浮点计算器早已经是128位甚至256位了。寻址能力64位就已经用不完了。使用大地址空间还会给精简指令处理器带来性能问题。而且在硬件设计上，需要更高的封装工艺，当然价格也更贵。总结来说就是性价比太低！
当然在某些专业领域，128位处理器已经有应用。比如说ps2。虽然在近几年不会在民用领域应用，不过随着需求的逐步提升和成本的下降，128位的处理器和系统有望为我们带来多的应用场景和更强的性能。
## 2.1练习题
8421
##### A.将 0x39A7F8转换为二进制
001110011010011111111000
##### B.将二进制1100100101111011转换为十六进制
C97B
##### C.将0xD5E4C转换为二进制
11010101111001001100
##### D.将二进制10 0110 1110 0111 1011 0101转换为十六进制
0x26E7B5

## 练习题2.2
100000000000
001000000000

| n | 2^n（十进制） | 2^n（十六进制） | 
|:-------:|:-------|:-------|
|9|512|0x200|
|19|524288|0x80000|
|14|16384|0x4000|
|16|65536|0x10000|
|17|131072|0x20000|
|5|32|0x20|
|7|128|0x80|

练习题真无聊啊！

## 寻址和字节顺序
0x123456
小端法：在内存中按照从最低有效字节到最高有效字节的顺序存储对象。即低地址对应低字节（倒序）

| 低地址 | -------> | 高地址 | 
|:-------:|:-------|:-------|
|0x56|...|0x12|

大端法：在内存中按照从最高有效字节到最低有效字节的顺序存储对象。即低地址对应高字节（正序）

| 低地址 | -------> | 高地址 | 
|:-------:|:-------|:-------|
|0x12|...|0x56|

一个判断大小端的方法，原理就是int是4个字节，强转为char单字节，b指向a的起始字节。
```
// 判断是大端还是小端
void endian()
{
    int a = 0x1122;
    char b = *(char *)&a;
    if (b == 0x11) {
        printf("大端");
    } else
    {
        printf("小端");
    }
}
```

**！生成一张ASCII表**
```
man ascii
```





















